<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Spring MVC菜鸟之旅] Spring MVC 与 MyBatis整合]]></title>
    <url>%2F2016%2F07%2F16%2FSpring-MVC%E8%8F%9C%E9%B8%9F%E4%B9%8B%E6%97%85-Spring-MVC-%E4%B8%8E-MyBatis%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[MyBatisMyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 整合MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 使用这个类库中的类, Spring 将会加载必要的 MyBatis 工厂类和 session 类。 这个类库也提供一个简单的方式来注入 MyBatis 数据映射器和 SqlSession 到业务层的 bean 中。 而且它也会处理事务, 翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常中。最终,它并 不会依赖于 MyBatis,Spring 或 MyBatis-Spring 来构建应用程序代码。 安装要使用MyBatis，并且使用Maven来构建项目，则只需将下面的dependency代码置于pom.xml文件中： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; 要和Spring一起使用MyBatis，我们需要在SPring应用上下文中定义至少两样东西：一个SqlSessionFactory 和至少一个数据映射器类。 从XML中构建SqlSessionFactory在 MyBatis-Spring中,SqlSessionFactoryBean 是用于创建SqlSessionFactory的。要配置这个工厂bean,放置下面的代码在 Spring的XML配置文件中: 123&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; 要注意SqlSessionFactoryBean需要一个DataSource（数据源）。这可以是任意的DataSource，配置它就像配置其他的Spring数据库连接是一样的。 123456&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; 创建数据映射器类我们创建的数据映射器类如下： 1234public interface TestMapper &#123; @Select("SELECT * From auth_user WHERE id = #&#123;id&#125;") Test getTest(@Param("id") long id);&#125; 然后用MapperFactoryBean将给接口加入到Spring中： 1234&lt;bean id="testMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.springmvc.niklaus.dao.TestMapper" /&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;&lt;/bean&gt; 注意所指定的映射器类必须是一个接口而不是具体的实现类。在这个实例中，注解被用来指定SQL语句，但是MyBatis的映射器XML文件也可以用，这个我将在下面再讲。 事务一个使用MyBatis-Spring的主要原因是它允许MyBatis参与到Spring的事务管理中，而不是给MyBatis创建一个新的特定的事务管理器。 12345&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 要开始Spring的事务管理，要在Spring的XML配置文件中创建一个DataSourceTransactionManager对象，然后使用指定transactionManager作为事务管理器，支持事务注解（@Transactional），此时在需要事务管理的Service上使用@Transactional注解就可以了，只会查找和它在相同的应用上下文件中定义的bean上面的@Transactional注解。 123456789101112@Service@Transactionalpublic class TestServiceImpl implements TestService&#123; @Autowired private TestMapper testMapper; public Test getTestById(long id) &#123; return testMapper.getTest(id); &#125;&#125; 结语先附上完整的MyBatis的配置XML文件spring-db.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;bean id="testMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.springmvc.niklaus.dao.TestMapper" /&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 这样，一个满足基本增删改查的Spring与MyBatis的整合应用就完成了，如果你想查看完整的项目代码，可以点击链接(SpringMVCRookie-dev-mybatis) 参考&amp;引用mybatismybatis-spring 更新时间发布时间 ： 2016-07-16]]></content>
      <categories>
        <category>Spring MVC菜鸟之旅</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Spring MVC菜鸟之旅] Spring Data Redis整合]]></title>
    <url>%2F2016%2F07%2F09%2FSpring-MVC%E8%8F%9C%E9%B8%9F%E4%B9%8B%E6%97%85-Spring-Data-Redis%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[The Spring Framework is the leading full-stack Java/JEE application framework. It provides a lightweight container and a non-invasive programming model enabled by the use of dependency injection, AOP, and portable service abstractions.NoSQL storages provide an alternative to classical RDBMS for horizontal scalability and speed. In terms of implementation, Key Value stores represent one of the largest (and oldest) members in the NoSQL space.The Spring Data Redis (or SDR) framework makes it easy to write Spring applications that use the Redis key value store by eliminating the redundant tasks and boiler plate code required for interacting with the store through Spring’s excellent infrastructure support. Redis使用Redis 此处简单介绍一下Linux下得Redis安装，windows比较麻烦没有尝试 下载、解压并编译Redis文件1234$ wget http://download.redis.io/releases/redis-3.2.4.tar.gz$ tar xzf redis-3.2.4.tar.gz$ cd redis-3.2.4$ make 运行redis-server1$ sudo ./src/redis-server 启动Redis客户端1$ sudo ./src/redis-cli Redis 数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 String（字符串）string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。 12345127.0.0.1:6379&gt; set name &quot;runoob&quot;OK127.0.0.1:6379&gt; get name&quot;runoob&quot;127.0.0.1:6379&gt; Hash（哈希）Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 123456789127.0.0.1:6379&gt; hmset user:1 username runoob password runoob points 200OK127.0.0.1:6379&gt; hgetall user:11) &quot;username&quot;2) &quot;runoob&quot;3) &quot;password&quot;4) &quot;runoob&quot;5) &quot;points&quot;6) &quot;200&quot; 以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis HMSET, HGETALL 命令，user:1 为键值。每个 hash 可以存储 232 -1 键值对（40多亿）。 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 12345678910127.0.0.1:6379&gt; lpush runoob redis(integer) 1127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2127.0.0.1:6379&gt; lpush runoob rabitmq(integer) 3127.0.0.1:6379&gt; lrange runoob 0 101) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 Set（集合）Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 sadd命令添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0,key对应的set不存在返回错误。 1sadd key member 123456789101112127.0.0.1:6379&gt; sadd runoobs redis(integer) 1127.0.0.1:6379&gt; sadd runoobs mongodb(integer) 1127.0.0.1:6379&gt; sadd runoobs rabitmq(integer) 1127.0.0.1:6379&gt; sadd runoobs rabitmq(integer) 0127.0.0.1:6379&gt; smembers runoobs1) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; 注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set : 有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 zadd命令添加元素到集合，元素在集合中存在则更新对应score 1zadd key score member 123456789101112127.0.0.1:6379&gt; zadd runoobz 0 redis(integer) 1127.0.0.1:6379&gt; zadd runoobz 0 mongodb(integer) 1127.0.0.1:6379&gt; zadd runoobz 0 rabitmaq(integer) 1127.0.0.1:6379&gt; zadd runoobz 0 rabitmaq(integer) 0127.0.0.1:6379&gt; zrangebyscore runoobz 0 101) &quot;mongodb&quot;2) &quot;rabitmaq&quot;3) &quot;redis&quot; 整合Spring Data RedisSpring Redis要求Redis的版本不低于2.6，Java SE版本不低于6.0，在语言绑定（连接器）方面，Spring Redis集成了Jedis，JRedis，SRP和Lettuce四个流行的Redis方面的Java库。 添加相关文件123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置RedisConnectionFactory1234567891011121314&lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxTotal" value="$&#123;redis.maxTotal&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWaitMillis&#125;" /&gt;&lt;/bean&gt;&lt;!-- Jedis ConnectionFactory --&gt;&lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;property name="hostName" value="$&#123;redis.hostname&#125;" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" /&gt; &lt;property name="usePool" value="true" /&gt; &lt;property name="poolConfig" ref="poolConfig" /&gt;&lt;/bean&gt; 通过RedisTemplate使用对象Most users are likely to use RedisTemplate and its coresponding package org.springframework.data.redis.core - the template is in fact the central class of the Redis module due to its rich feature set. The template offers a high-level abstraction for Redis interactions. While RedisConnection offers low level methods that accept and return binary values (byte arrays), the template takes care of serialization and connection management, freeing the user from dealing with such details. 1234567891011&lt;!-- Serializer --&gt;&lt;!-- 如果不配置Serializer，那么存储的时候只能使用String，如果存储其他类型的对象，将会提示错误--&gt;&lt;bean id="keySerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;&lt;bean id="valueSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;&lt;!-- redis template definition --&gt;&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="jedisConnectionFactory" /&gt; &lt;property name="keySerializer" ref="keySerializer"/&gt; &lt;property name="valueSerializer" ref="valueSerializer"/&gt;&lt;/bean&gt; RedisTemplate uses a Java-based serializer for most of its operations. This means that any object written or read by the template will be serialized/deserialized through Java. The serialization mechanism can be easily changed on the template, and the Redis module offers several implementations available in the org.springframework.data.redis.serializer package - see Serializers for more information. You can also set any of the serializers to null and use RedisTemplate with raw byte arrays by setting the enableDefaultSerializer property to false. Note that the template requires all keys to be non-null - values can be null as long as the underlying serializer accepts them; read the javadoc of each serializer for more information. 1234567891011121314151617package com.springmvc.niklaus.dao.Impl;@Repositorypublic class TestDAOImpl implements TestDAO&#123; @Resource private RedisTemplate&lt;String,String&gt; redisTemplate; public void rSave(String key,String value)&#123; redisTemplate.opsForValue().set(key,value); &#125; public String rGet(String key)&#123; return redisTemplate.opsForValue().get(key); &#125;&#125; 参考&amp;引用RedisSpring Data RedisSpring Data Redis - APISpring Data Redis - Projects 更新时间发布时间 ： 2016-07-09]]></content>
      <categories>
        <category>Spring MVC菜鸟之旅</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Spring MVC菜鸟之旅] 通过配置文件分析Spring MVC与Hibernate的整合]]></title>
    <url>%2F2016%2F07%2F03%2FSpring-MVC%E8%8F%9C%E9%B8%9F%E4%B9%8B%E6%97%85-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90Spring-MVC%E4%B8%8EHibernate%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[前言当使用Spring开发持久层的时候，我们会面临多种选择。我们可以使用JDBC、Hibernate、MyBatis或其他任意的持久化框架。在这里简单介绍一下使用Hibernate作为持久化框架。 Spring的数据访问哲学Spring的目标之一就是允许开发人员在开发应用程序时，能够遵循面向对象（OO）原则中的“针对接口编程”。Spring对数据访问的支持也不例外。DAO是数据访问对象（data access object）的缩写。DAO提供了数据读取和写入到数据库中的一种方式。它们应该以接口的方式发布功能，而应用程序的其他部分就可以通过接口来进行访问。下图展现了设计数据访问层的合理方式。 如上图所示，服务对象通过接口来访问DAO。这样的好处有:(1) 服务对象易于测试，因为它们不再与特定的数据访问实现绑定在一起。(2) 数据访问层是以持久化技术无关的方式来进行访问。持久化方式的选择独立于DAO，只要相关的数据访问方法通过接口来进行发布。这可以实现灵活的设计并使得切换持久化框架对应用程序其他部分所带来的影响最小。如果将数据层的实现细节渗透到应用程序的其他部分中，那么整个应用程序将于数据访问层耦合在一起，从而导致僵化的设计。 配置数据源Spring提供了在Spring上下文中配置数据源Bean的多种方式，包括：(1) 通过JDBC驱动程序定义的数据源；(2) 通过JNDI查找的数据源；(3) 连接池的数据源对于即将发布到生产环境中的应用程序，我建议使用从连接池获取连接的数据源。我们把所有有关于Hibernate的配置都放置在resource目录下spring-db.xml的文件上 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUrl"&gt; &lt;value&gt;$&#123;jdbc.url&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="user"&gt; &lt;value&gt;$&#123;jdbc.username&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;$&#123;jdbc.password&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="minPoolSize"&gt; &lt;value&gt;$&#123;jdbc.pool.min&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="maxPoolSize"&gt; &lt;value&gt;$&#123;jdbc.pool.max&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="initialPoolSize"&gt; &lt;value&gt;$&#123;jdbc.pool.init&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="maxStatements"&gt; &lt;value&gt;$&#123;jdbc.pool.maxStatements&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="maxIdleTime"&gt; &lt;value&gt;$&#123;jdbc.pool.maxIdleTime&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="idleConnectionTestPeriod"&gt; &lt;value&gt;$&#123;jdbc.pool.idleConnectionTestPeriod&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="acquireRetryAttempts"&gt; &lt;value&gt;$&#123;jdbc.pool.acquireRetryAttempts&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="breakAfterAcquireFailure"&gt; &lt;value&gt;$&#123;jdbc.pool.breakAfterAcquireFailure&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="testConnectionOnCheckout"&gt; &lt;value&gt;$&#123;jdbc.pool.testConnectionOnCheckout&#125;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 在Spring中集成Hibernate声明Hibernate的Session工厂以前，在Spring应用程序中使用的Hibernate是通过HibernateTemplate进行的，它简化了Hibernate的繁琐工作，它的职责之一是管理Hibernate的Session。这涉及打开和关闭Session并确保每个事务使用相同的Session。HibernateTemplate的不足之处在于存在一定程度的侵入性。但我们在DAO中使用HibernateTemplate（不管直接使用还是通过HibernateDaoSupport）时，DAO类都会与SpringAPI产生耦合。 Hibernate3引入了上下文Session（Contextual session），这是Hibernate本身所提供的保证每个事务使用同一Session的方案。这种方式能够让你的DAO类不包含特定的Spring代码。我在《[Spring MVC菜鸟之旅] Spring MVC 与 Hibernate整合》中就是使用HibernateTemplate，但鉴于上下文Session是使用Hibernate的最佳实践，所以下面的介绍将只关注上下文Session。 使用Hibernate的主要接口实org.hibernate.Session。Session接口提供了基本的数据访问功能，通过Hibernate的Session接口，应用程序的DAO能够满足所有的持久化需求。 获取Hibernate Session对象的标准方式是借助Hibernate的SessionFactory接口的实现类。除了一些其他的任务，SessionFactory主要负责Hibernate Session的打开。关闭以及管理。 在Spring中我们通过SPring的某一个Hibernate Session工厂Bean来获取Hibernate的SessionFactory。我们可以在应用程序的Spring上下文中，像配置其他Bean那样来配置Hibernate Session工厂。在配置Hibernate Session工厂的Bean的时候，我们一般在持久化域对象是通过XML来进行配置的。当选在XML中定义对象与数据库之间的映射，需要在Spring中配置LocalSessionFactoryBean（若更倾向使用注解的方式来定义持久化的话，需要使用AnnotationSessionFactoryBean配置） 1234567891011121314151617&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.niklaus.springmvc.pojo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 使用packagesToScan属性告诉Spring扫描一个或多个包以查找域类，这些类通过注解方式来表明要使用Hibernate进行持久化。 12345&lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.niklaus.springmvc.pojo&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 因为我只需要扫描一个包，所以我使用了一个内部的属性编辑器将单个的String自动转换为String数组。 构建不依赖于Spring的Hibernate代码在Spring应用上下文中配置Hibernate Session工厂Bean后，可以准备创建自己的DAO类了。 12345678910111213141516171819202122232425262728293031323334@Repositorypublic class TestDAOImpl implements TestDAO&#123; private SessionFactory sessionFactory; //构造DAO @Autowired public TestDAOImpl(SessionFactory sessionFactory)&#123; this.sessionFactory = sessionFactory; &#125; public void addTest(Test test) &#123; Session session = sessionFactory.openSession(); Transaction tx = session.beginTransaction(); session.save(test); tx.commit(); session.close(); &#125; public Test getTestById(long id) &#123; Session session = sessionFactory.openSession(); Test test = (Test) session.get(Test.class,id); session.close(); return test; &#125; public void updateTest(Test test) &#123; Session session = sessionFactory.openSession(); Transaction tx = session.beginTransaction(); session.update(test); tx.commit(); session.close(); &#125;&#125; 事务管理在软件开发领域，全有或全无的操作被称为事务（transaction）。事务允许你讲几个操作组合成一个要么全部发生要么全部不发生的工作单元。如果一切顺利，事务将会成功。但是有任何一件事情出错的话，所发生的行为将会被清除干净，就像什么事情都没有发生一样。 事务特性（ACID）原子性（Atomic）事务是由一个或多个活动所组成的一个工作单元。原子性确保食物中的所有操作全部发生或者全部不发生。如果所有活动都成功了，事务也就成功了。如果任意一个活动失败了，整个事务也失败并回滚。 一致性（Consistent）一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态。现实的数据不应该被损坏。 隔离性（Isolated）事务允许多个用户对相同的数据进行操作，每个用户的操作不会与其他用户纠缠在一起。因此，事务应该被彼此隔离，避免发生同步读写相同数据的事情（注意的是，隔离性往往涉及到锁定数据库中的行或表）。 持久性（Durable）一旦事务完成，事务的结果应该持久化，这样就能从任何的系统崩溃中会发过来。这一般会设计将结果存储到数据库或者其他形式的持久化存储中。 使用Hibernate事务管理器如果应用程序的持久化是通过Hibernate实现的，那么久需要使用HibernateTransactionManager。需要在Spring上下文定义中添加如下的声明： 123&lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt; HibernateTransactionManager将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法。类似地，如果事务失败，Transaction对象的rollback()方法将会被调用。 声明式事务在XML中定义事务Spring为POJO提供了声明式事务的支持，它是通过Spring AOP框架实现的。Spring提供了3种方式来声明事务式边界，包括Spring AOP和TransactionProxyFactory的代理Bean来实现声明式事务，但自从Spring 2.0，声明事务的更好方式是使用Spring的tx命名空间和@Transactional注解。使用tx命名空间会涉及将其添加到Spring XML配置文件中： 12345678&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; 要注意的是，aop命名空间也应该包括在内。这是很重要的，因为有一些声明式事务配置元素依赖于部分Spring的AOP配置元素。 1234567&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 定义方法的过滤规则 --&gt; &lt;tx:attributes&gt; &lt;!-- 所有方法都使用事务 --&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 当使用来声明事务时，还需要一个事务管理器。根据约定优于配置，假定事务管理器被声明为一个id为transactionManager的Bean。如果碰巧为事务管理配置器配置了一个不同的id，则需要在transactionmanager属性中明确指定事务管理器的id。 只是定义了AOP通知，用于吧事务边界通知给方法。但是这只是事务通知，而不是完整的事务性切面。我们在中没有声明哪些Bean应该被通知—我们需要一个切点来做这件事。为了完整定义事务性切面，我们必须定义一个通知器（advisor）。 12345&lt;aop:config&gt; &lt;!-- 定义一个切入点 --&gt; &lt;aop:pointcut id="services" expression="execution (* com.springmvc.niklaus.service.*Service.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="services" /&gt;&lt;/aop:config&gt; 这里的pointcut属性使用了AspectJ切入点表达式来表明通知器适用于哪些方法。哪些方法应该真正运行在事务中以及方法的事务属性都是由这个事务通知来定义的，而事务通知是advice-ref属性来制定的，它引用了名为txAdvice的通知。 定义注解驱动的事务除了元素，tx命名空间还提供了元素，使用时，通常只需要一行XML： 1&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 通过transaction-manager属性（默认值为transactionManager）来制定特定的事务管理器。 元素告诉Spring检索上下文中所有的Bean并查找使用@Transactional注解的Bean，而不管这个注解使用在类级别上还是方法级别上。对于每一个使用@Transactional注解的Bean，都会自动为它添加事务通知。通知的事务属性是通过@Transactional注解的参数来定义的。 小结github地址 SpringMVCRookie 参考&amp;引用《spring实战(第三版)》 更新时间发布时间 ： 2016-07-03]]></content>
      <categories>
        <category>Spring MVC菜鸟之旅</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Spring MVC菜鸟之旅] Spring MVC 与 Hibernate整合]]></title>
    <url>%2F2016%2F07%2F02%2FSpring-MVC%E8%8F%9C%E9%B8%9F%E4%B9%8B%E6%97%85-Spring-MVC-%E4%B8%8E-Hibernate%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[应用结构先贴上一张本文最终运行成功的Spring MVC程序的结构图 配置项目使用Maven导入SpringMVC所依赖的包，修改pom.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.nicklaus.springmvc&lt;/groupId&gt; &lt;artifactId&gt;springmvc&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springmvc Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;4.3.11.Final&lt;/hibernate.version&gt; &lt;mysql.version&gt;5.1.29&lt;/mysql.version&gt; &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring end --&gt; &lt;!--hibernate--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库连接池C3P0--&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl for jsp page --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springmvc&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.1.v20140609&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 修改WEB-INF下的web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;display-name&gt;SpringMVCDemo&lt;/display-name&gt; &lt;!-- 配置spring应用上下文 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置spring核心servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 保持之前dispatcher-servlet.xml内容不变12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;!-- 处理静态资源 --&gt; &lt;mvc:resources location="resources" mapping="/resources/**"/&gt; &lt;!-- 启动注解驱动的Spring MVC功能，注册请求url和注解POJO类方法的映射--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 启动包扫描功能，以便注册带有@Controller、@Service、@repository、@Component等注解的类成为spring的bean --&gt; &lt;context:component-scan base-package="com.niklaus.springmvc" /&gt; &lt;!-- 对模型视图名称的解析，在请求时模型视图名称添加前后缀 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在resource目录下创建applicationContext.xml文件123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:dev/config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;import resource="spring-db.xml" /&gt;&lt;/beans&gt; 在resource目录下创建spring-db.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUrl"&gt; &lt;value&gt;$&#123;jdbc.url&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="user"&gt; &lt;value&gt;$&#123;jdbc.username&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;$&#123;jdbc.password&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="minPoolSize"&gt; &lt;value&gt;$&#123;jdbc.pool.min&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="maxPoolSize"&gt; &lt;value&gt;$&#123;jdbc.pool.max&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="initialPoolSize"&gt; &lt;value&gt;$&#123;jdbc.pool.init&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="maxStatements"&gt; &lt;value&gt;$&#123;jdbc.pool.maxStatements&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="maxIdleTime"&gt; &lt;value&gt;$&#123;jdbc.pool.maxIdleTime&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="idleConnectionTestPeriod"&gt; &lt;value&gt;$&#123;jdbc.pool.idleConnectionTestPeriod&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="acquireRetryAttempts"&gt; &lt;value&gt;$&#123;jdbc.pool.acquireRetryAttempts&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="breakAfterAcquireFailure"&gt; &lt;value&gt;$&#123;jdbc.pool.breakAfterAcquireFailure&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name="testConnectionOnCheckout"&gt; &lt;value&gt;$&#123;jdbc.pool.testConnectionOnCheckout&#125;&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.niklaus.springmvc.pojo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate4.HibernateTemplate"&gt; &lt;property name="sessionFactory"&gt; &lt;ref bean="sessionFactory" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 定义方法的过滤规则 --&gt; &lt;tx:attributes&gt; &lt;!-- 所有方法都使用事务 --&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;!-- 定义一个切入点 --&gt; &lt;aop:pointcut id="services" expression="execution (* com.niklaus.springmvc.service.*Service.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="services" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 将配置数据源的配置信息写入config.properties文件中 12345678910111213#mysql configurationjdbc.url=jdbc\:mysql\://10.1.1.00\:3306/xxxxx?autoReconnect\=true&amp;useUnicode\=true&amp;characterEncoding\=UTF-8jdbc.username=rootjdbc.password=jdbc.pool.min=5jdbc.pool.max=50jdbc.pool.maxIdleTime=180jdbc.pool.init=5jdbc.pool.idleConnectionTestPeriod=1800jdbc.pool.maxStatements=100jdbc.pool.acquireRetryAttempts=30jdbc.pool.breakAfterAcquireFailure=falsejdbc.pool.testConnectionOnCheckout=false 编写数据交互的代码创建数据表12345678910CREATE TABLE `auth_user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(30) NOT NULL, `email` VARCHAR(75) NOT NULL, `password` VARCHAR(128) NOT NULL, `last_login` DATETIME NOT NULL, `date_joined` DATETIME NOT NULL, PRIMARY KEY (`id`), UNIQUE INDEX `username` (`username`)) Pojo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.niklaus.springmvc.pojo;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.util.Date;/** * Created by nicholas.chi on 2016/7/2. */@Entity@Table(name = "auth_user")public class Test &#123; private long id; private String userName; private String email; private String password; private Date lastLogin; private Date dateJoined; @Id @Column(name = "id", unique = true, nullable = false) public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; @Column(name = "username") public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; @Column(name = "email") public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Column(name = "password") public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Column(name = "last_login") public Date getLastLogin() &#123; return lastLogin; &#125; public void setLastLogin(Date lastLogin) &#123; this.lastLogin = lastLogin; &#125; @Column(name = "date_joined") public Date getDateJoined() &#123; return dateJoined; &#125; public void setDateJoined(Date dateJoined) &#123; this.dateJoined = dateJoined; &#125; @Override public String toString() &#123; return "Test&#123;" + "id=" + id + ", userName='" + userName + '\'' + ", email='" + email + '\'' + ", password='" + password + '\'' + ", lastLogin=" + lastLogin + ", dateJoined=" + dateJoined + '&#125;'; &#125;&#125; Dao层接口 12345678910111213141516171819202122package com.niklaus.springmvc.dao;import com.niklaus.springmvc.pojo.Test;import java.util.List;/** * Created by nicholas.chi on 2016/7/2. */public interface TestDao &#123; public void testAdd(Test test); public void testDelete(Test test); public void testUpdate(Test test); public Test getTestById(long id); public List&lt;Test&gt; getAll();&#125; 实现 1234567891011121314151617181920212223242526272829303132333435363738394041package com.niklaus.springmvc.dao.Impl;import com.niklaus.springmvc.dao.TestDao;import com.niklaus.springmvc.pojo.Test;import org.springframework.orm.hibernate4.HibernateTemplate;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import java.util.List;/** * Created by nicholas.chi on 2016/7/2. */@Repositorypublic class TestDaoImpl implements TestDao&#123; @Resource HibernateTemplate hibernateTemplate; public void testAdd(Test test) &#123; hibernateTemplate.save(test); &#125; public void testDelete(Test test) &#123; hibernateTemplate.delete(test); &#125; public void testUpdate(Test test) &#123; hibernateTemplate.update(test); &#125; public Test getTestById(long id) &#123; Test test = hibernateTemplate.get(Test.class,id); return test; &#125; public List&lt;Test&gt; getAll() &#123; List&lt;?&gt; list = hibernateTemplate.find("from Test where id &gt; 0"); return (List&lt;Test&gt;)list; &#125;&#125; Service层接口1234567891011121314151617package com.niklaus.springmvc.service;import com.niklaus.springmvc.pojo.Test;import java.util.List;/** * Created by nicholas.chi on 2016/7/2. */public interface TestService &#123; public List&lt;Test&gt; getAllUser(); public void addUser(Test test);&#125; 实现123456789101112131415161718192021222324252627package com.niklaus.springmvc.service.Impl;import com.niklaus.springmvc.dao.TestDao;import com.niklaus.springmvc.pojo.Test;import com.niklaus.springmvc.service.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * Created by nicholas.chi on 2016/7/2. */@Servicepublic class TestServiceImpl implements TestService&#123; @Autowired TestDao testDao; public List&lt;Test&gt; getAllUser() &#123; return testDao.getAll(); &#125; public void addUser(Test test) &#123; testDao.testAdd(test); &#125;&#125; Controller层123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.niklaus.springmvc.controller;import com.niklaus.springmvc.pojo.Test;import com.niklaus.springmvc.service.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.Date;import java.util.List;/** * Created by nicholas.chi on 2016/7/2. */@Controllerpublic class TestController &#123; @Autowired TestService testService; @RequestMapping(value="/test",method = RequestMethod.GET) public String test()&#123; List&lt;Test&gt; list = testService.getAllUser(); for(int i = 0;i&lt;list.size();i++)&#123; System.out.println("Test Num : "+i); System.out.println("Test content : "+list.get(i).toString()); &#125; return "index"; &#125; @RequestMapping(value="/testAdd",method = RequestMethod.GET) public String testAdd()&#123; Test test = new Test(); test.setUserName("Tests"); test.setEmail("test@teat.com"); test.setPassword("XXXXXXXXXXXXXXXXXXXXXX"); test.setDateJoined(new Date()); test.setLastLogin(new Date()); testService.addUser(test); return "index"; &#125;&#125; 效果验证在浏览器中访问http://localhost:10086/springmvc/test，会发现IDE的Console会打印如下信息： 123456789101112131415Hibernate: select test0_.id as id1_0_, test0_.date_joined as date_joi2_0_, test0_.email as email3_0_, test0_.last_login as last_log4_0_, test0_.password as password5_0_, test0_.username as username6_0_ from auth_user test0_ where test0_.id&gt;0Test Num : 0Test content : Test&#123;id=1, userName=&apos;kerry&apos;, email=&apos;kerry.liu@yuyutechnology.com&apos;, password=&apos;e10adc3949ba59abbe56e057f20f883e&apos;, lastLogin=2016-02-03 14:48:12.0, dateJoined=2016-02-02 18:23:13.0&#125;Test Num : 1Test content : Test&#123;id=2, userName=&apos;a&apos;, email=&apos;a@a.com&apos;, password=&apos;e10adc3949ba59abbe56e057f20f883e&apos;, lastLogin=2016-02-03 14:38:22.0, dateJoined=2016-02-03 11:29:23.0&#125;Test Num : 2Test content : Test&#123;id=3, userName=&apos;b&apos;, email=&apos;b@b.com&apos;, password=&apos;e10adc3949ba59abbe56e057f20f883e&apos;, lastLogin=2016-02-03 11:48:30.0, dateJoined=2016-02-03 11:48:30.0&#125;Test Num : 3Test content : Test&#123;id=4, userName=&apos;test&apos;, email=&apos;test@test.com&apos;, password=&apos;e10adc3949ba59abbe56e057f20f883e&apos;, lastLogin=2016-02-03 12:04:32.0, dateJoined=2016-02-03 12:03:29.0&#125;Test Num : 4Test content : Test&#123;id=5, userName=&apos;test2&apos;, email=&apos;test2@test.com&apos;, password=&apos;e10adc3949ba59abbe56e057f20f883e&apos;, lastLogin=2016-02-03 12:07:00.0, dateJoined=2016-02-03 12:07:00.0&#125;Test Num : 5Test content : Test&#123;id=6, userName=&apos;c&apos;, email=&apos;c@c.com&apos;, password=&apos;202cb962ac59075b964b07152d234b70&apos;, lastLogin=2016-02-03 12:21:44.0, dateJoined=2016-02-03 12:21:44.0&#125;Test Num : 6Test content : Test&#123;id=7, userName=&apos;123&apos;, email=&apos;123@123.com&apos;, password=&apos;dddd&apos;, lastLogin=2016-07-15 18:00:27.0, dateJoined=2016-07-15 18:00:27.0&#125; 由以上的信息可以看出，我们成功连接到了数据库，并且能从中获取我们想要的数据，但是这并不意味这我们将Spring MVC 和Hibernate整合成功了，如果我们此时去访问http://localhost:10086/springmvc/testAdd，就会发现页面提示500错误信息。 其中我们从org.springframework.dao.InvalidDataAccessApiUsageException: Write operations are not allowed in read-only mode (FlushMode.MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove ‘readOnly’ marker from transaction definition.错误提示中可以知道，当前正处于read-only状态，只允许读操作，不允许写操作。 解决问题修改dispatcher-servlet.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;!-- 处理静态资源 --&gt; &lt;mvc:resources location="resources" mapping="/resources/**"/&gt; &lt;!-- 启动注解驱动的Spring MVC功能，注册请求url和注解POJO类方法的映射--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 启动包扫描功能，以便注册带有@Controller、@Service、@repository、@Component等注解的类成为spring的bean --&gt; &lt;!--&lt;context:component-scan base-package="com.niklaus.springmvc" /&gt;--&gt; &lt;context:component-scan base-package="com.niklaus.springmvc" use-default-filters="false" &gt; &lt;context:include-filter expression="org.springframework.stereotype.Controller" type="annotation"/&gt; &lt;/context:component-scan&gt; &lt;!-- 对模型视图名称的解析，在请求时模型视图名称添加前后缀 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 修改applicationContext.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:dev/config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:component-scan base-package="com.niklaus.springmvc" &gt; &lt;context:exclude-filter expression="org.springframework.stereotype.Controller" type="annotation"/&gt; &lt;/context:component-scan&gt; &lt;import resource="spring-db.xml" /&gt;&lt;/beans&gt; 保存好修改内容之后，再次访问 http://localhost:10086/springmvc/testAdd ，发现此时不再报错，然后查看数据库发现确实增加了username为Tests的 一条数据 结语直到此时我们才将Spring MVC 和 Hibernate框架初步整合，支持增删改查等一系列数据交互的操作。如果需要更加强大的功能，还需要后续的步骤。(其实我想说，你需要力量吗，氪金吧O(∩_∩)O) 参考&amp;引用更新时间发布时间 ： 2016-07-02]]></content>
      <categories>
        <category>Spring MVC菜鸟之旅</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Spring MVC菜鸟之旅] 通过配置文件看最简单的Spring MVC应用程序]]></title>
    <url>%2F2016%2F06%2F26%2FSpring-MVC%E8%8F%9C%E9%B8%9F%E4%B9%8B%E6%97%85-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9C%8B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Spring-MVC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Spirng MVCSpring MVC是什么？Spring MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦,基于请求驱动指的是使用请求-相应模型，框架的目的就是帮助我们简化开发，Spring MVC也是要简化我们日常Web开发的。 核心架构图 具体流程 用户发送请求 —&gt; DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。 DispatcherServlet —&gt; HandlerMapping，HandlerMapping将会把请求映射为HandlerExecutionChain（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器对象）对象，通过这种策略模式，很容易添加新的映射策略。 DispatcherServlet —&gt; HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器。 HandlerAdapter —&gt; 处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。 ModelAndView逻辑视图名 —&gt; ViewResolver，ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术。 View —&gt; 渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术。 返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。 配置文件web.xml Java 的Web应用程序中通常都会有一个web.xml文件，这个文件是不是必须的呢？ 要回答上面的问题，首先要了解web.xml文件到底有什么用，web.xml文件是用来配置欢迎页、servlet、filter等的。如果你的应用程序中没有用到这些，自然就不需要web.xml文件了。 Spring MVC的核心是DispatcherServlet，这个Servlet充当Spring MVC的前端控制器。与其他Servlet一样，DispatcherServlet必须在Web应用程序的web.xml文件中进行配置。所以在应用程序中使用Spring MVC的第一件事就是将下面的声明放入web.xml中去： 12345&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 默认情况下，DispatcherServlet在加载时会从一个基于配置名字的XML文件中加载Spring应用上下文。在这个示例中，因为servlet的名字为dispatcher，DispatcherServlet将尝试从一个名为dispatcher-servlet.xml的文件（位于应用程序的WEB-INF目录下）来加载应用上下文。 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 上面示例中声明了DispatcherServlet处理那些URL。通过将DispatcherServlet映射到 / ,声明了它会作为默认的servlet并且会处理所有的请求，包括对静态资源的请求。 dispatcher-servlet.xml根据web.xml文件的配置，我们需要在WEB-INF目录下创建dispatcher-servlet.xml文件，DispatcherServlet将使用它来创建应用上下文，而我们也将对Spring MVC的配置写在这个文件上。 静态资源访问1&lt;mvc:resources location="/resources/**" mapping="/resources/" /&gt; 正如前面所述，所有经过DispatcherServlet的请求必须以一定的方式来进行处理，而通常情况下是需要用控制器进行处理。静态资源的请求也需要通过DispatcherServlet，我们需要以某种方式来告诉DispatcherServlet如何处理这些资源。 恰好元素就是做这个的，它建立了一个服务于静态资源的处理器。属性mapping表明路径必须以/resources开始，而且也包括他的任意自路径。属性location表明了要提供服务的文件位置。以上配置表明，所有以/resources路径开头的请求都会自动由应用程序根目录下的/resources目录提供服务。因此我们的所有图片、样式表、JavaScript以及其他的静态资源都必须放在应用程序的/resources目录下。 配置注解驱动的Spring MVC在dispatcher-servlet.xml文件中添加一行配置就能得到Spring MVC所提供的注解驱动特性： 1&lt;mvc:annotation-driven /&gt; 默认扫描包路径 123456789101112Controller@RequestMapping(value="/system")public class SystemController &#123; @RequestMapping(value="/login",method=RequestMethod.GET) public ModelAndView login()&#123; ModelAndView mav = new ModelAndView("login"); System.out.println("login"); return mav; &#125;&#125; 我们先来看一下上一篇文中用作测试的SystemController，虽说比较简单，但还是有许多内容需要介绍。首先@Controller注解表明这个类是一个控制器类。这个类是@Component注解的一种具体化，也就是说将查找使用@Component注解的类并将其注册为Bean，就像它们使用@Component注解那样。 这意味着我们需要在dispatcher-servlet.xml文件中配置一个，这样SystemController类（以及将要编写的所有其他控制器）竟会自动被发现并注册为Bean。以下是相关的XML片段。 1&lt;context:component-scan base-package="com.niklaus.learn" /&gt; 解析视图处理请求的最后一件必须要做的事情就是为用户渲染输出。为了确定值定的请求需要使用哪个视图，DispatcherServlet会查找一个视图解析器来将控制器返回的逻辑视图名称转换成渲染结果的实际视图。在Spring MVC中，大量使用了约定优于配置的开发模式。InternalResourceViewResolver就是一个面向约定的元素。它将逻辑视图名称解析为View对象，而该对象将渲染的任务委托给Web应用程序上下文的一个模板（通常是JSP）。它通过为逻辑视图名称添加前缀和后缀来确定Web应用程序中的模板路径。假设我们已经将应用程序的所有JSP放在“/WEB-INF/views/”目录下。基于这样的安排，我们需要在dispatcher-servlet.xml中配置InternalResourceViewResolver，如下所示： 12345&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/views/" /&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; 参考&amp;引用 《Spring实战（第3版）》 《跟开涛学Spring MVC》 更新时间发布时间 ： 2016-06-26]]></content>
      <categories>
        <category>Spring MVC菜鸟之旅</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Spring MVC菜鸟之旅] 搭建一个最简单的Spring MVC应用程序]]></title>
    <url>%2F2016%2F06%2F25%2FSpring-MVC%E8%8F%9C%E9%B8%9F%E4%B9%8B%E6%97%85-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Spring-MVC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[应用结构先贴上一张本文最终运行成功的Spring MVC程序的结构图 项目搭建1.使用Maven导入SpringMVC所依赖的包，修改pom.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.niklaus.learning&lt;/groupId&gt; &lt;artifactId&gt;learning&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0-b01&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.修改WEB-INF下的web.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;!-- 配置spring核心servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.在WEB-INF下创建dispatcher-servlet.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd" default-lazy-init="true"&gt; &lt;!-- 处理对静态资源的请求 --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources/" /&gt; &lt;!-- 添加注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 默认扫描的包路径 --&gt; &lt;context:component-scan base-package="com.niklaus.learn" /&gt; &lt;!-- 对模型视图名称的解析，在请求时模型视图名称添加前后缀 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/views/" /&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 项目测试根据dispatcher-servlet.xml配置在/WEB-INF/views下创建前台页面login.jsp123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;LOGIN&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello,World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 根据dispatcher-servlet.xml配置的包路径，创建controller12345678910111213141516171819package com.niklaus.learn.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(value="/system")public class SystemController &#123; @RequestMapping(value="/login",method=RequestMethod.GET) public ModelAndView login()&#123; ModelAndView mav = new ModelAndView("login"); System.out.println("login"); return mav; &#125;&#125; 部署项目，并访问http://localhost:8080/system/login 结束如此我们就完成了一个最为简单的SpringMVC项目 更新时间 发布时间 ： 2016-06-25]]></content>
      <categories>
        <category>Spring MVC菜鸟之旅</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何在同一台电脑配置多个git或者github账号]]></title>
    <url>%2F2016%2F06%2F18%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E6%88%96%E8%80%85github%E8%B4%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[问题描述当有多个git账号的时候，比如一个github，用于自己进行一些开发活动，再来一个gitlab，一般是公司内部的git。这两者你的邮箱如果不同的话，就会涉及到一个问题，生成第二个git的key的时候会覆盖第一个的key，导致必然有一个用不了。 问题解决所谓多个git账号，可能有两种情况： 1 拥有多个github账号，不同的账号对应不同的repo，需要push的时候自动区分账号。 2 拥有多个git的账号，有的是github的，有个事gitlab的，不同的账号对应不同的repo url，需要push的时候自动区分账号。 这两种情况的处理方法是一样的，假设我有两个账号，一个是github上的，一个是gitlab上面的。 生成SSH Key生成第一个ssh key（这里我用于github）1ssh-keygen -t rsa -C &quot;yourmail@github.com&quot; 一路回车下去，生成结果如下图所示： 默认情况下，这个rsa秘钥是在你个人账户的.ssh目录下，存在id_rsa私钥文件和id_rsa.pub公钥文件。然后复制公钥文件中的字符串。进入github账户setting选项SSh and GPC keys，把复制的公钥字符串黏贴到Key的输入框中，保存退出即可。 通过终端ssh测试可知，出现如下提示内容，说明秘钥已经生成并且添加成功。 1ssh -T git@github.com 生成第二个ssh key（这里我用于gitLab）1ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitLab -C &quot;youremail@gitLab.com&quot; 通过上面的命令，你会发现在~/.ssh目录下又多了id_rsa_gitLab和id_rsa_gitLab.pub两个文件。同样复制id_rsa_gitLab.pub公钥文件中的字符串，进入gitLab账户Profile选项SSH keys下，把复制的公钥字符串黏贴到Key的输入框中，保存退出即可。 添加秘钥到SSH agent因为默认只读取id_rsa,为了让SSH识别新的私钥，需将其添加的SSH agent中。这里如果你用的github官方的bash，ssh-agent -s,如果是其他的，比如msysgit,eval $(ssh-agent -s) 如果出现 Could not open a connection to your authentication agent 的错误，就是这用一下命令： 123ssh-agent bashssh-add ~/.ssh/id_rsa_gitssh-add ~/.ssh/id_rsa_gitLab 最后可以通过下面命令，查看key的设置 1ssh-add -l 创建并配置config文件在windows下新建一个txt文本，然后将名字后缀一起改成config即可；而在Linux下的话，在.ssh 目录下，直接vim config,如果在bash下，可以通过以下命令生成config文件 1touch config 向空白的config文件中添加一下内容 12345678910111213# gitlabHost git.aspectgaming.comHostName git.aspectgaming.com PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitLabUser nicholas.chi# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser git 测试 补充如果之前有设置全局用户名和邮箱的话，需要unset一下 12git config --global --unset user.namegit config --global --unset user.email 然后在不同的仓库下设置局部的用户名和邮箱 12git config user.email “xxxx@xx.com”git config user.name “xxxx 这样，以后每次在对应的repo下提交修改，都会自动匹配相应的SSH-Key。 参考&amp;引用管理git生成的多个ssh key 一台电脑存放多个git账户的多个rsa秘钥 如何同一台电脑配置多个git或github账号 更新时间发布时间 ： 2016-06-18]]></content>
  </entry>
  <entry>
    <title><![CDATA[git将本地仓库上传到远程仓库]]></title>
    <url>%2F2016%2F06%2F11%2Fgit%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目的在已有的git库中搭建新库，并且将本地的git仓库，上传到远程服务器的git库中，从而开始一个新的项目。 不登录远程git服务器直接本地操作初始化仓库1git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 对指定文件的追踪1git add . 提交操作1git commit -m &apos;first commit&apos; 当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照 添加远程仓库1git remote add origin git@xx.xx.xx.xx:repos/xxx/xxx/xxx.git 推送本地分支到远程仓库1git push origin (remote):(branch) 推送本地的 remote 分支，将其作为远程仓库的 branch 分支，可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 出现问题问题1the file will have its original line endings in your working directory 1git config --global core.autocrlf false 问题2fatal:unable to access ‘xxx/xxx/xxx/…’:Filename too long 相关问题Filename too long in git for windows 1git config --global core.longpaths true 问题3fatal: Not a valid object name: ‘master’ 相关问题git 错误 fatal: Not a valid object name: ‘master’. 问题4error:dst ref refs/heads/source receives form more than one src. 1git push origin (remote):(branch) 在remote与branch中间的：不要遗漏，否则就会出现以上问题 参考&amp;引用git官方文档 git将本地仓库上传到远程仓库 更新时间发布时间 ： 2016-06-11]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ Idea使用那些事]]></title>
    <url>%2F2016%2F06%2F04%2FIntelliJ-Idea%E4%BD%BF%E7%94%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[配置JettyRun/Debug Configurations按下图标识打开Run/Debug Configurations面板 commond line 添加配置1org.mortbay.jetty:maven-jetty-plugin:6.1.22:run 修改端口Runner选项-&gt;VM Options 设置 1-Djetty.port=10086 pom文件添加plugin12345678910&lt;build&gt; &lt;finalName&gt;springmvc&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.1.v20140609&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 参考&amp;引用更新时间发布时间 ： 2016-06-04]]></content>
      <tags>
        <tag>IntelliJ Idea</tag>
      </tags>
  </entry>
</search>